unit mainFrm;

interface

uses
  System.SysUtils, System.Classes,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs,System.IniFiles,
  cxButtons,
  cxDropDownEdit, cxLabel, cxTextEdit,
  SQLServerUniProvider, DBAccess, Uni, cxGraphics, cxControls, cxLookAndFeels,
  cxLookAndFeelPainters, cxContainer, cxEdit, Vcl.Menus, UniProvider, Data.DB,
  Vcl.StdCtrls, cxMaskEdit, dxShellDialogs, MemDS;

type
  TfrmMain = class(TForm)
    edtServer: TcxTextEdit;
    cxLabel1: TcxLabel;
    edtDatabase: TcxTextEdit;
    cxLabel2: TcxLabel;
    edtusername: TcxTextEdit;
    cxLabel3: TcxLabel;
    edtPassword: TcxTextEdit;
    cxLabel4: TcxLabel;
    cxLabel5: TcxLabel;
    cbAuthType: TcxComboBox;
    btnTest: TcxButton;
    btnKaydet: TcxButton;
    UniConntest: TUniConnection;
    provider: TSQLServerUniProvider;
    cxButton1: TcxButton;
    Memo1: TMemo;
    UniQuery1: TUniQuery;
    procedure FormCreate(Sender: TObject);
    function TestConnection(AShowInfo : boolean = true): boolean;
    procedure btnTestClick(Sender: TObject);
    procedure btnKaydetClick(Sender: TObject);
    procedure cxButton1Click(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

const
  CKEY1 = 53761;
  CKEY2 = 32618;

var
  frmMain: TfrmMain;

implementation

{$R *.dfm}


function EncryptStr(const S :WideString; Key: Word): String;
var
  i     :Integer;
  RStr  :RawByteString;
  RStrB :TBytes Absolute RStr;
begin
  Result:= '';
  RStr:= UTF8Encode(S);
  for i := 0 to Length(RStr)-1 do begin
    RStrB[i] := RStrB[i] xor (Key shr 8);
    Key := (RStrB[i] + Key) * CKEY1 + CKEY2;
  end;
  for i := 0 to Length(RStr)-1 do begin
    Result:= Result + IntToHex(RStrB[i], 2);
  end;
end;

function DecryptStr(const S: String; Key: Word): String;
var   i, tmpKey  :Integer;
      RStr       :RawByteString;
      RStrB      :TBytes Absolute RStr;
      tmpStr     :string;
begin
  tmpStr:= UpperCase(S);
  SetLength(RStr, Length(tmpStr) div 2);
  i:= 1;
  try
    while (i < Length(tmpStr)) do begin
      RStrB[i div 2]:= StrToInt('$' + tmpStr[i] + tmpStr[i+1]);
      Inc(i, 2);
    end;
  except on E : Exception do
    begin
      Result:= e.Message;
      Exit;
    end;
  end;

  for i := 0 to Length(RStr)-1 do begin
    tmpKey:= RStrB[i];
    RStrB[i] := RStrB[i] xor (Key shr 8);
    Key := (tmpKey + Key) * CKEY1 + CKEY2;
  end;
  Result:= UTF8Decode(RStr);
end;

function TfrmMain.TestConnection(AShowInfo : boolean = true): boolean;
begin
  if (Trim(edtServer.text) = EmptyStr)
    // or (Trim(edtDatabase.text) = EmptyStr)
  then
  begin
    ShowMessage('Veritabaný bilgileri eksik');
    exit;
  end;

  if cbAuthType.ItemIndex = 1 then
  begin
    if (Trim(edtusername.text) = EmptyStr) or
       (Trim(edtPassword.text) = EmptyStr)
    then
    begin
      ShowMessage('Veritabaný bilgileri eksik');
      exit;
    end;
  end;


  UniConntest.Connected := False;
  UniConntest.ProviderName := 'SQL Server';
  UniConntest.Server   := edtServer.text;
  UniConntest.Database := edtDatabase.text;

  if cbAuthType.ItemIndex = 0 then
  begin
    // Windows Authentication
    UniConntest.Username := '';
    UniConntest.Password := '';
    UniConntest.SpecificOptions.Values['Authentication'] := 'auWindows';
  end
  else
  begin
    // SQL Server Authentication
    UniConntest.Username := edtusername.text;
    UniConntest.Password := edtpassword.text;
    UniConntest.SpecificOptions.Values['Authentication'] := 'auServer';
  end;

  UniConntest.LoginPrompt := False;

  try
    UniConntest.Connect;
    if AShowInfo then ShowMessage('Baðlantý baþarýlý');
    Result := True;
  except
    on E: Exception do
    begin
      if AShowInfo then ShowMessage('Veritabanýna baðlanýlamadý:' + sLineBreak + E.Message);
      Result := false;
    end;

  end;
end;

procedure TfrmMain.btnKaydetClick(Sender: TObject);
var
  Ini: TIniFile;
begin
  if TestConnection then
  begin
    Ini := TIniFile.Create(ExtractFilePath(ParamStr(0)) + 'khpro.ini');
    try
      Ini.WriteString('Database', 'Server', edtServer.text);
      Ini.WriteString('Database', 'Database', edtdatabase.text);
      Ini.WriteString('Database', 'AuthType', cbAuthType.Text);
      Ini.WriteString('Database', 'Username', edtusername.text);
      Ini.WriteString('Database', 'Password', EncryptStr(edtPassword.text, 123));
    finally
      Ini.Free;
    end;
  end;
end;

procedure TfrmMain.btnTestClick(Sender: TObject);
begin
  TestConnection;
end;

procedure TfrmMain.cxButton1Click(Sender: TObject);
begin
  UniQuery1.sql := memo1.lines;
  UniQuery1.Execute;
end;

procedure TfrmMain.FormCreate(Sender: TObject);
var
  Ini: TIniFile;
begin
  Memo1.Text := StringReplace(Memo1.Text, 'backup_dirr',  ExtractFilePath(ParamStr(0)), [rfReplaceAll] );
  Memo1.Text := StringReplace(Memo1.Text, 'app_dirr',  ExtractFilePath(ParamStr(0)), [rfReplaceAll] );

  if FileExists(ExtractFilePath(ParamStr(0)) + 'khpro.ini') then
  begin
    Ini := TIniFile.Create(ExtractFilePath(ParamStr(0)) + 'khpro.ini');
    try
      edtServer.text   := Ini.ReadString('Database', 'Server', '');
      edtDatabase.text := Ini.ReadString('Database', 'Database', '');

      if Ini.ReadString('Database', 'AuthType', '') = 'Windows Auth' then
        cbAuthType.itemindex := 0
      else
        cbAuthType.itemindex := 1;

      edtusername.text   := Ini.ReadString('Database', 'Username', '');
      edtPassword.text   := DecryptStr(Ini.ReadString('Database', 'Password', ''), 123);
    finally
      Ini.Free;
    end;
  end;

end;

end.
